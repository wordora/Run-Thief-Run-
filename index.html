<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mobile Snake Game</title>
    <style>
        /* ... (keep all previous CSS styles the same) ... */
    </style>
</head>
<body>
    <!-- ... (keep all previous HTML the same) ... -->

    <script>
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const speedDisplay = document.getElementById('speed-display');
        const scoreDisplay = document.getElementById('score-display');
        const gameOverScreen = document.getElementById('game-over');
        const finalScoreSpan = document.getElementById('final-score');
        const finalSpeedSpan = document.getElementById('final-speed');
        const warning = document.getElementById('warning');

        // Game constants
        const GRID_SIZE = 20;
        const GRID_COUNT = canvas.width / GRID_SIZE;
        const RED_BALL_INTERVAL = 15000;
        const RED_BALL_DURATION = 5000;
        const BASE_SPEED = 300;
        const SPEED_MULTIPLIER = 0.96; // 4% faster each food

        // Game state
        let snake = [];
        let food = {};
        let redBall = null;
        let dx = GRID_SIZE;
        let dy = 0;
        let score = 0;
        let gameLoop;
        let currentSpeed = BASE_SPEED;
        let speedLevel = 1;
        let isGameOver = false;
        let redBallTimeout = null;
        let redBallInterval = null;

        // Mobile controls (fixed event listeners)
        const addMobileControl = (id, dir) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                move(dir);
            });
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                move(dir);
            });
        };

        addMobileControl('up-btn', 'up');
        addMobileControl('down-btn', 'down');
        addMobileControl('left-btn', 'left');
        addMobileControl('right-btn', 'right');

        function initGame() {
            snake = [
                {x: 5 * GRID_SIZE, y: 5 * GRID_SIZE},
                {x: 4 * GRID_SIZE, y: 5 * GRID_SIZE},
                {x: 3 * GRID_SIZE, y: 5 * GRID_SIZE}
            ];
            spawnFood();
            score = 0;
            dx = GRID_SIZE;
            dy = 0;
            currentSpeed = BASE_SPEED;
            speedLevel = 1;
            isGameOver = false;
            updateDisplays();
            gameOverScreen.style.display = 'none';
            clearTimeout(redBallTimeout);
            redBall = null;
            warning.style.display = 'none';
            clearInterval(redBallInterval);
            redBallInterval = null;
        }

        function spawnFood() {
            do {
                food = {
                    x: Math.floor(Math.random() * GRID_COUNT) * GRID_SIZE,
                    y: Math.floor(Math.random() * GRID_COUNT) * GRID_SIZE
                };
            } while (snake.some(segment => segment.x === food.x && segment.y === food.y));
        }

        function spawnRedBall() {
            if (isGameOver) return;
            
            warning.style.display = 'block';
            setTimeout(() => warning.style.display = 'none', 2000);

            redBall = {
                x: Math.floor(Math.random() * GRID_COUNT) * GRID_SIZE,
                y: Math.floor(Math.random() * GRID_COUNT) * GRID_SIZE,
                size: GRID_SIZE * 2
            };

            redBallTimeout = setTimeout(() => redBall = null, RED_BALL_DURATION);
        }

        function drawGame() {
            ctx.fillStyle = '#ecf0f1';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw food
            ctx.fillStyle = '#f1c40f';
            ctx.beginPath();
            ctx.arc(food.x + GRID_SIZE/2, food.y + GRID_SIZE/2, GRID_SIZE/2 - 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw red ball
            if (redBall) {
                ctx.fillStyle = '#e74c3c';
                ctx.beginPath();
                ctx.arc(redBall.x + GRID_SIZE, redBall.y + GRID_SIZE, 
                        redBall.size/2, 0, Math.PI * 2);
                ctx.fill();
            }

            // Draw snake
            snake.forEach((segment, index) => {
                ctx.fillStyle = index === 0 ? '#2ecc71' : '#27ae60';
                ctx.fillRect(segment.x, segment.y, GRID_SIZE - 2, GRID_SIZE - 2);
            });
        }

        function checkCollisions() {
            const head = snake[0];
            return head.x < 0 || head.x >= canvas.width || 
                   head.y < 0 || head.y >= canvas.height ||
                   snake.slice(1).some(segment => segment.x === head.x && segment.y === head.y);
        }

        function checkRedBallCollision() {
            if (!redBall) return false;
            const head = snake[0];
            const distance = Math.sqrt(
                Math.pow(head.x + GRID_SIZE/2 - (redBall.x + GRID_SIZE), 2) +
                Math.pow(head.y + GRID_SIZE/2 - (redBall.y + GRID_SIZE), 2)
            );
            return distance < (GRID_SIZE/2 + redBall.size/2);
        }

        function increaseSpeed() {
            currentSpeed = Math.max(50, currentSpeed * SPEED_MULTIPLIER);
            speedLevel = (BASE_SPEED / currentSpeed).toFixed(2);
            updateDisplays();
            clearInterval(gameLoop);
            gameLoop = setInterval(moveSnake, currentSpeed);
        }

        function moveSnake() {
            if (isGameOver) return;

            const head = {x: snake[0].x + dx, y: snake[0].y + dy};
            snake.unshift(head);

            if (checkCollisions()) return gameOver();

            if (head.x === food.x && head.y === food.y) {
                score += 10;
                spawnFood();
                increaseSpeed();
            } else {
                snake.pop();
            }

            if (checkRedBallCollision()) {
                score += 50;
                clearTimeout(redBallTimeout);
                redBall = null;
            }

            drawGame();
            scoreDisplay.textContent = `Score: ${score}`;
        }

        function move(direction) {
            if (isGameOver) return;
            switch(direction) {
                case 'up': 
                    if (dy === 0) {
                        dx = 0;
                        dy = -GRID_SIZE;
                    }
                    break;
                case 'down': 
                    if (dy === 0) {
                        dx = 0;
                        dy = GRID_SIZE;
                    }
                    break;
                case 'left': 
                    if (dx === 0) {
                        dx = -GRID_SIZE;
                        dy = 0;
                    }
                    break;
                case 'right': 
                    if (dx === 0) {
                        dx = GRID_SIZE;
                        dy = 0;
                    }
                    break;
            }
        }

        function gameOver() {
            isGameOver = true;
            clearInterval(gameLoop);
            gameOverScreen.style.display = 'block';
            finalScoreSpan.textContent = score;
            finalSpeedSpan.textContent = `${speedLevel}x`;
            clearTimeout(redBallTimeout);
            clearInterval(redBallInterval);
        }

        function updateDisplays() {
            scoreDisplay.textContent = `Score: ${score}`;
            speedDisplay.textContent = `Speed: ${speedLevel}x`;
        }

        function startGame() {
            clearInterval(gameLoop);
            clearInterval(redBallInterval);
            initGame();
            gameLoop = setInterval(moveSnake, currentSpeed);
            redBallInterval = setInterval(spawnRedBall, RED_BALL_INTERVAL);
        }

        // Keyboard controls (fixed with preventDefault)
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': move('up'); e.preventDefault(); break;
                case 'ArrowDown': move('down'); e.preventDefault(); break;
                case 'ArrowLeft': move('left'); e.preventDefault(); break;
                case 'ArrowRight': move('right'); e.preventDefault(); break;
            }
        });

        // Initialize game
        drawGame();
    </script>
</body>
</html>
